### 并发机制的底层原理

- volatile
  定义：若是被volatile修饰的字段，java内存模型保证每个线程都能看到这个字段的值是一致的
  原理：在volatile 字段在写操作时的汇编指令来看，增加了一条Lock前缀的指令。
  	Lock前缀指令的影响：
  	1）将当前处理器的缓存写回到系统内存中。
  	2）这个写回操作会使其他CPU里缓存了该内存地址的数据无效(简单来说就是一个处理器缓存写回到内存会使其他处理器的缓存无效)。
  volatile使用优化：
  	在使用volatile变量时，尽量追加到64字节。

个人理解的原理：当使用volatile 修饰变量时，每次该变量的修改，都会在底层增加一条lock 指令，会即时将新值写回到系统内存中，并保证其他处理器缓存中的值无效化；当别的处理器使用该变量时，会重新从系统内存中取。

- synchronized
  使用：
  1）对于普通同步方法，锁是当前实例对象。
  2）对于静态同步方法，索是当前类的Class对象。
  3）对于同步方法块，锁是synchronized括号里配置的对象。
  原理：synchronized方法块，编译以后，monitorenter指令回插到方法块前面，monitorexit指令回插到异常处或者结束处，任何对象都一个monitor与之关联，当monitor被持有以后，它将处于锁定状态。

- 锁的状态
  级别由低到高：无锁状态（01）--偏向锁状态（01）--轻量级锁状态（00）-重量级锁状态（10）

- 在理解锁状态变化之前要先来了解----java对象头
  java对象头内含：MarkWord（对象的hashCode或者锁信息等）、对象类型的数据的指针、数组的长度（当对象是数组对象时才有）。
  重点：MarkWord 包含：hashCode、对象分代年龄、是否是偏向锁、锁标志位。（注意：并不是所有的MarkWord 都含有这些东西，例如轻量级锁只含有指向栈中锁记录的指针和锁标志位）

- 偏向锁
  	获取：当一个线程访问一个锁（同步代码块）时，会在对象头和该线程栈帧的锁记录中存入锁偏向的线程ID，并将对象头的“是否是偏向锁”置为1，当该线程再次访问这个锁时，会简单的测试一下对象头中的MarkWord 是否有该线程ID的偏向锁。成功了表示线程已经获得了该锁；若是失败了，则会测试对象头MarkWord 的“是否是偏向锁”是否置为1，如果设置了，则尝试用CAS操作将偏向锁指向该线程；若是没设置，则尝试CAS竞争该锁。
  	释放：当一个线程获得偏向锁后，执行完同步块，若有其他线程竞争该锁，该线程就会停止，然后解锁并将对象头MarkWord 的线程ID置为空，最后恢复线程。

- 轻量级锁
  	获取：当线程1获得锁，执行同步块，首先会将对象头的MarkWord 复制一份放到自己栈中的存储锁记录的空间中（Displaced MarkWord），然后将MarkWord 替换为指向栈帧中锁记录的指针，若是成功，表示获取该锁；若是失败，表示有其他的线程在竞争锁，线程1就会进入自旋来获取锁。
  	释放：①线程1尝试CAS将Displaced MarkWord替换回到 MarkWord，若是成功，表示释放；若是失败，表示有其他的线程在竞争锁。②其他线程在自旋获取锁失败后，会使轻量级锁膨胀为重量级锁，并且自身被阻塞。线程1操作①失败，就会释放该锁，并唤醒阻塞线程。

- 原子操作原理
  1 处理器实现原子操作原理：
  	①总线锁定：当一个处理器在总线上输出 Lock #信号，其他处理器就会被阻塞，该处理器就会独享内存。
  	②缓存锁定：内存区域如果被缓存到了处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行所操作写回到内存时，处理器不会在总线		   上发出 Lock # 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。因为缓存一致性机制会阻止修		   改多个处理器缓存的内存区域数据。
  2 java实现原子操作的原理：
  	①使用循环CAS实现原子操作。
  		CAS实现原子操作的三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。
  	②锁机制实现原子操作。

​			



### 第二章 java内存模型

（抽象）内存模型：多个线程之间通过内存进行通信。例如：线程A将变量a写入自己的本地内存，再写入主内存；线程B将主内存中的a 复制一份到自己的本地内存再读。
基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。

重排序：对于不改变代码执行结果，JMM（java内存模型）允许将代码顺序改变，进行优化。
重排序顺序：源代码-->编译器重排序-->指令级重排序（处理器）-->内存系统重排序（处理器）-->最终执行的指令序列

- 内存屏障
  - ① A LoadLoad B ：保证A读先于B及其后续操作。
    ② A StoreStore B ：保证A写（刷新到内存）先于B及其后续操作。
    ③ A LoadStore B ：保证A读先于B写。
    ④ A StoreLoad B ：保证A写先于B读，保证指令之前的所有访问指令执行完后才能执行屏障之后的（全能型屏障，拥有其他三个屏障功能）。

- happens-before规则
  - 1 程序顺序规则：字面意思。
    2 监视器锁规则：一个锁的释放，先于这个锁的获取。
    3 volatile变量规则：一个volatile变量的写，先于volatile变量的读。
    4 传递性：A先于B，B先于C，则A先于C。
    5 start()规则：一个线程start()操作，会先于这个线程的任意操作。
    6 join()规则：线程A执行线程B的join()操作并成功返回，那么线程B的任意操作先于线程A从线程B的join()操作成功返回。

- as-if-serial语义
  不管怎么重排序，（单线程）程序的执行结果不能被改变。

！！！注意：happens-before规则针对多线程；as-if-serial语义针对单线程。

- volatile的内存语义
  可见性：对于一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
  原子性：对于任意单个volatile变量的读/写具有原子性，但是类似于volatile++这种复合操作不具有原子性。

- volatile写/读的内存语义
  个人理解：写：线程A向线程B发送消息
  	 读：线程B接收线程A发送的消息
  	 写-读：线程A通过主内存向线程B发送消息

- volatile内存语义的实现
  基于内存屏障：在volatile变量的前后插入对应的内存屏障。详情自己去找

- 锁的内存语义
  一个锁的释放，先于这个锁的获取
  锁的释放与volatile写相同，锁的获取与volatile读相同。

- 锁内存语义的实现
  1 公平锁和非公平锁的释放，都要写入一个volatile变量state
  2 公平锁获取时，首先会去读volatile变量
  3 非公平锁获取时，首先会有CAS更新volatile变量，这个操作同时具有volatile读/写的内存语义。
  可以看出：锁释放-获取的内存语义的实现有两种
  ① 利用volatile变量的写-读所具有的内存语义。
  ② 利用CAS所附带的volatile读和volatile写的内存语义。


！！注意：锁的内存语义的实现：1 基于volatile读/写内存语义 
			    2 基于CAS操作：CAS操作的源代码，如果是单线程，不会有lock前缀；如果时多线程会加上lock前缀
				lock前缀的作用：①保证对内存的读-改-写操作原子执行
					       ②禁止该指令，与之前和之后的读和写指令重排序
  					       ③把写缓冲区中的所有数据刷新到主内存中

- final域的内存语义
  对于final域，编译器和处理器要遵守两个重排序规则
  ① 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
  ② 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

- 写final域的重排序规则
  ① 禁止编译器把final域的写重排序到构造函数之外。
  ② 编译器会在final域写之后，构造方法return之前，插入一个StoreStore内存屏障，来禁止处理器把final域重排序到构造函数之外。

- 读final域的重排序规则
  在一个线程中，初次读对象引用与初次读该对象包含的final域，禁止处理器重排序这两个操作（注意：这个规则仅仅针对处理器）

- 注意：当final域为引用类型（例如数组）对编译器和处理器增加了如下约束：在构造函数内对一个fianl引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。


- JMM(java内存模型)
  happen-before 是JMM最核心的概念。
  JMM设计考虑到的因素：
  ① 便于程序员编写
  ② 便于编译器和处理器进行优化

- happen-before 关系的定义
  ① 如果一个操作happen-before 里一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
  ② 两个操作之间存在happen-before关系，并不意味着java平台的具体实现必须要按照happen-before关系指定的顺序来执行。如果重排序之后的执行结果不变，那么这种重排序不非法，可以进行。


！！双重检查锁定于延迟初始化：自行了解

### 第三章 并发编程基础

-  线程：操作系统的最小单元，也叫轻量级进程，拥有各自的计数器，堆栈和局部变量等属性，并且能够访问共享的内存变量。
   多线程的好处：更多的处理器核心、更快的响应时间、更好的编程模型
   线程优先级：默认为5，范围是1-10。  （注意这个优先级没什么大用、因为操作系统可以完全不用理会java线程对于优先级的设定）

- 线程的状态
  new 初始状态，线程被构建，但是没有调用start()方法。
  runnable 运行状态（包括就绪和运行）
  blocked 阻塞状态
  waiting 等待状态
  time_waiting 超时等待
  terminated 终止状态

- Daemon线程（了解就行）
  Daemon线程被用作完成支持性工作，但是在java虚拟机退出时Daemon线程中的finally块 并不一定会执行。
  通过setDaemon（true/false）方法，来设置线程是否是Daemon线程。

- 线程的初始化：最好自行了解。
  线程的启动：调用start()方法
  中断：可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。即线程B调用线程A的interrupt()方法,中断了		线程A；线程A也可以通过isInterrupted()方法来判断是否被中断，也可以用Thread.interrupted()方法，对当前线程进行复位。
  安全的终止线程：线程A可以通过中断操作和cancel()方法使线程B终止。。

- 线程之间的通信
  	每一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程首先要获取到该对象的监视器才能执行同步块或者同步方法，若是没有获得监视器，线程就会被阻塞在同步块和同步方法的入口处，进入阻塞状态。图1描述了该关系。
- ![1568003710438](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568003710438.png)

- 等待/通知机制
  等待/通知机制：一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()方法或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。 线程A和线程B通过对象O来完成交互。
- ![1568003765822](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568003765822.png)
- ！！！一般这个对象O就是线程获取的锁对象。而当线程调用了这个锁（对象O）的wait()方法等，就会释放该锁。过程如图2
  等待方遵循如下原则：
  ①获取对象的锁
  ②如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。
  ③条件满足则执行对应的逻辑。
  通知方遵循如下原则：
  ①获得对象的锁
  ②改变条件
  ③通知所有等待在对象上的线程。

- Thread.join()的使用
  一个线程A执行了线程B.join()语句，其含义：当前线程A等待线程B中止之后才从线程B.join()返回。还有join(long millis)超时方法。

- 
  ThreadLocal 的使用：自行了解。


### 第四章 Java中的锁

- Lock锁
  Lock 是一个接口
  使用：
  Lock lock = new() ReentrantLock();
  lock.lock();
  try{
  }finally{
  	lock.unlock();
  }
  注意：同一个lock对象锁是同一把；必须在finally语块中释放lock，否则容易造成线程死锁。

- #### ！！！  lock 和 synchronized 的区别

   		                   synchronized             					                                       lock

 存在层次	     Java的关键字，在jvm层面上 					                     	是一个类

 锁的释放       1、以获取锁的线程执行完同步代码，释放锁			      在finally中必须释放锁，不然容易造成线程死锁
	                   2、线程执行发生异常，jvm会让线程释放锁

 锁的获取	   假设A线程获得锁，B线程等待。				                      分情况而定，Lock有多个锁获取的方式。
		               如果A线程阻塞，B线程会一直等待				                  尝试非阻塞获得锁、能被中断地获取锁、
					   超时获取锁

 锁状态           无法判断							                                                          可以判断

 锁类型           可重入 不可中断 非公平					                                  可重入 可判断 可公平/不公平（两者皆可）

 性能		       少量同步							                                                       大量同步

- 队列同步器（AQS，AbstractQueuedSynchronizer）
  	同步器的主要使用方式是继承，一般作为同步器组件的静态内部类，在同步器中仅定义了与状态相关的方法，且这个状态既可以独占地获取又可以共享的获取，这样就可以实现不同类型的同步组件（ReetrantLock、ReetrantReadWriteLock和CountDownLatch等）。同步器是同步组件实现锁的关键，我们通常使用同步组件来实现各种锁的功能，而其内部实际上是利用同步器进行锁的实现。它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。
  	同步器的设计是基于模板的。使用者需要重写同步器指定的方法，然后将同步器组合在自定义同步组件的视线中，并调用同步器提供的模板方法。而这些模板方法就是调用同步器使用者重写的方法。
  	
  核心方法
  getState():获取当前同步状态
  setState(int  newState):设置当前同步状态
  compareAndSetState(int expect,int update):使用CAS设置当前状态，该方法能保证状态设置的原子性。

  可重写的方法
  tryAcquire(int arg) :独占式获取同步状态，该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态

  tryRelease(int arg) ：独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态

  tryAcquireShared(int  arg) ：共享式获取同步状态，返回大于等于0的值，表示获取成功，否则失败

  tryReleaseShared(int arg)： 共享式释放同步状态

  isHeldExclusively() ：当前同步器是否在独占模式下被线程占用，一般该方法表示是否被前当线程多独占



- 个人理解：设计同步器，就是在一个实现Lock接口的A类里面，创建一个静态内部类（同步器）继承AQS，通过调用核心方法，来重写方法。最后在A类里面通过调用模板方法，来实现加锁，释放锁等方法。


- 同步队列的实现：请自行查找资料。
  独占/共享式同步状态获取与释放：请自行查找资料。

- 重入锁(ReentrantLock)：表示锁能够支持一个线程对资源的重复加锁。初次之外，该锁还支持获取锁时的公平和非公平性选择。具体实现自行了解。
  公平和平公平获取锁的区别：公平获取：按照FIFO顺序获取锁。非公平：竞争的获取锁。
  读写锁（ReentrantReadWriteLock）：允许多个读线程获取锁。自行了解

- LockSupprot 工具：线程的阻塞和唤醒。
  使用：LockSupport.park()阻塞；LockSupport.unpark()唤醒。

- Condition 接口
  使用：
  ① 线程A先获取锁 lock.lock();
  ② 线程A调用Lock.newCondition()获取Condition对象
  ③ 线程A直接调用condition.await()方法，让当前线程进入 等待状态
  ④ 线程B获取锁，直接调用condition.signal()方法

  等同于 等待/通知（wait/notify）
  其实现自行了解。



### 第五章 并发容器和框架

- ConcurrentHashMap 实现原理与使用
  结构：由Segment数组结构和HashEntry数据结构组成
  Segment：是一种可重入锁，在ConcurrentHashMap 扮演锁的角色
  HashEntry：用于存储键值对数据。
  	一个ConcurrentHashMap  包含一个Segment数组，Segment的结构和HashMap（哈希表）类似，是一种数组和链表结构; 一个Segment里面包含一个HashEntry数组,每个HashEntry 是一个链表结构的元素，每个Segment守护着一个HashEntry数组。

  ConcurrentHashMap 初始化原理：自行了解
  操作：get()、put()、size()。

  ConcurrentLinkedQueue 队列结构（线程安全）
  结构：有head节点和tail节点组成，每个节点由节点元素（item）和指向下一个节点（next）组成。链表结构。
  入队列和出队列原理：自行了解

- 阻塞队列
  阻塞队列是一个支持两个附加操作的队列。这两个附加操作支持阻塞的插入和移除方法
  1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。
  2）支持阻塞的移除方法：意思时在队列为空时，获取元素的线程会等待队列变为非空。
  实现原理：使用通知模式实现：当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。

  java中的7个阻塞队列
  1）ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。
  2）LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。
  3）PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。
  4）DelayQueue：一个使用优先级队列实现的无界阻塞队列。
  5）SynchronousQueue：一个不储存元素的阻塞队列。
  6）LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
  7）LinkedBlockingQueue：一个由链表结构组成的双向阻塞队列。
  其实现原理自行了解

#### Fork/Join框架



### 第六章 Java中的13个原子操作类

- 原子更新基本类型类
  AtomicBoolean：原子更新布尔类型。
  AtomicInteger：原子更行整型。
  AtomicLong：原子更新长整型。

  原子更新数组
  AtomicIntegerArray：原子更新整型数组里的元素。
  AtomicLongArray：原子更新长整型数组里的元素。
  AtomicReferenceArray：原子更新引用类型数组里的元素。

  原子更新引用类型
  AtomicReference：原子更新引用类型。
  AtomicReferenceFieldUpdater：原子更新引用类型里的字段。
  AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。

  原子更新字段类
  AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。
  AtomicLongFieldUpdater：原子更新长整型字段的更新器。
  AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。



### 第七章 Java中的并发类工具

- 等待多线程完成的CountDownLatch
  CountDownLatch的构造函数接受一个int类型的参为作为计数器，如果你想等待N个点完成，这里就传入N。
  当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程知道N变成0。
  CountDownLatch实现了join的功能。
  具体使用：自行了解

- 同步屏障CyclicBarrier
  作用：让一组线程到达一个屏障（同步点）时被阻塞，知道最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。
  CyclicBarrier默认的构造方法是CyclicBarrier（int parties） ，其参数表示屏障拦截的线程数量，每个线程电用await方法告诉CyclicBarrier
  我已经到达屏障，然后当前线程被阻塞。
  注意：当被阻塞的线程被放行时，不一定会按照之前线程执行的顺序继续执行。例如 线程A-线程B 屏障  线程B-线程A

- CountDownLatch和CyclicBarrier的区别
  CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，所以CyclicBarrier能处理更为复杂的业务场景。

- 控制并发线程数的Semaphore 和 线程间交换数据的Exchanger
  具体使用自行了解



### 第八章 Java中的线程池

- 线程池的实现原理：
  1 线程池的处理流程：
  	1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务；如果是，则进入下个流程。
  	2）线程池判断工作队列是否已满。如没满，则将新提交的任务存储在这个工作队列里；如满了，则进入下个流程。
  	3) 线程池判断线程池的线程是否都处于工作状态。如没有，则创建一个新的工作线程来执行任务。如果是，则交给饱和策略来处理这个任务。